---
layout: post
title: "Kotlin 1.1新特性"
date: 2017-12-24
excerpt: "从Kotlin 1.1开始，JavaScript目标不再认为是实验性的。"
tags: [sample post, readability, test]
comments: true
---
# [What's New in 1.1](http://kotlinlang.org/docs/reference/whatsnew11.html) Kotlin 1.1新特性
目录：
- Coroutines 协程
- 其他语言特性
- 标准库
- JVM 后端
- JavaScript 后端

## JavaScript
从Kotlin 1.1开始，JavaScript目标不再认为是实验性的。所有语言特性都支持，还有许多新工具可用于与前后端开发环境集成。有关更改的更详细列表，请参阅[下文](http://kotlinlang.org/docs/reference/whatsnew11.html#javascript-backend)。

## Coroutines协程 （实验性的）
Kotlin 1.1主要的特性是协程，支持`async`/`await`，`yield`的类似编程模式。Kotlin设计的主要特性就是协同执行的实现是库的一部分，而不是语言，所以你不必受任何特定的编程返利或并发库的约束。

协程实际上是一种轻量级的线程，可以暂停和之后恢复，协程的支持是通过 [suspending functions](http://kotlinlang.org/docs/reference/coroutines.html#suspending-functions) （挂起函数）：调用这样的函数可能会暂停协程，并启用一个新的协程，我们通常使用匿名suspending functions（比如挂起的lambdas）。

让我们来看看`async`/`await`，这是在外部库实现的，[kotlinx.coroutnes](https://github.com/kotlin/kotlinx.coroutines):

```kotlin
// runs the code in the background thread pool
fun asyncOverlay() = async(CommonPool) {
    // start two async operations
    val original = asyncLoadImage("original")
    val overlay = asyncLoadImage("overlay")
    // and then apply overlay to both results
    applyOverlay(original.await(), overlay.await())
}

// launches new coroutine in UI context
launch(UI) {
    // wait for async overlay to complete
    val image = asyncOverlay().await()
    // and then show it in UI
    showImage(image)
}
```
这里，`async { ... }`开启了一个协程，当我们使用`await()`，等待的操作被执行时，协程的执行被暂停，当等待的操作执行完成后协程的执行会恢复（可能在不同的线程上）。

标准库使用协程来支持具有`yield`和`yieldAll`函数的延迟生成的队列。在这样的序列中，返回序列元素的代码块在每个元素被取回后被暂停，并且当请求下一个元素时被恢复，以下是一个例子：

```kotlin
import kotlin.coroutines.experimental.*

fun main(args: Array<String>) {
    val seq = buildSequence {
        for (i in 1..5) {
            // yield a square of i
            yield(i * i)
        }
        // yield a range
        yieldAll(26..28)
    }

    // print the sequence
    println(seq.toList())
}
```
有关更多的信息，请参阅 [coroutine文档](http://kotlinlang.org/docs/reference/coroutines.html)和[教程](http://kotlinlang.org/docs/tutorials/coroutines-basic-jvm.html)。

请注意，协程程序目前被认为是一个实验功能，这意味着Kotlin团队在最终的1.1版本之后不承诺支持此功能的向后兼容性。

## 其他语言特性
### Type aliases 类型别名
类型别名允许你为现有类型定义一个替代名称，这对于通用类型（如集合）以及函数类型很有用，以下是一个例子：

```kotlin
typealias OscarWinners = Map<String, String>

fun countLaLaLand(oscarWinners: OscarWinners) =
oscarWinners.count { it.value.contains("La La Land") }

// Note that the type names (initial and the type alias) are interchangeable:
fun checkLaLaLandIsTheBestMovie(oscarWinners: Map<String, String>) =
oscarWinners["Best picture"] == "La La Land"

fun oscarWinners(): OscarWinners {
    return mapOf(
            "Best song" to "City of Stars (La La Land)",
            "Best actress" to "Emma Stone (La La Land)",
            "Best picture" to "Moonlight" /* ... */)
}

fun main(args: Array<String>) {
    val oscarWinners = oscarWinners()

    val laLaLandAwards = countLaLaLand(oscarWinners)
    println("LaLaLandAwards = $laLaLandAwards (in our small example), but actually it's 6.")

    val laLaLandIsTheBestMovie = checkLaLaLandIsTheBestMovie(oscarWinners)
    println("LaLaLandIsTheBestMovie = $laLaLandIsTheBestMovie")
}
```
有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/type-aliases.html)和[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md)。

### Bound callable references 绑定可调用的引用
你可以用`::`运算符来获取指向特定对象实例的方法或属性的成员引用。 以前只能用lambda表示。 以下是一个例子：

```kotlin
val numberRegex = "\\d+".toRegex()
val numbers = listOf("abc", "123", "456").filter(numberRegex::matches)

fun main(args: Array<String>) {
    println("Result is $numbers")
}
```
有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11)和[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/bound-callable-references.md)。

### Sealed和data类
Kotlin 1.1删除了Kotlin 1.0中存在的封装和数据类的一些限制。 现在，你可以在同一个文件的顶层定义顶级seald类的子类，而不仅仅是seald类的嵌套类。 Data类现在可以扩展其他类。 这可以用来很好地和清晰地定义表达式类的层次结构：

```kotlin
sealed class Expr

data class Const(val number: Double) : Expr()
data class Sum(val e1: Expr, val e2: Expr) : Expr()
object NotANumber : Expr()

fun eval(expr: Expr): Double = when (expr) {
    is Const -> expr.number
    is Sum -> eval(expr.e1) + eval(expr.e2)
    NotANumber -> Double.NaN
}
val e = eval(Sum(Const(1.0), Const(2.0)))

fun main(args: Array<String>) {
    println("e is $e") // 3.0
}
```
有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/sealed-classes.html)或[sealed类](https://github.com/Kotlin/KEEP/blob/master/proposals/sealed-class-inheritance.md)和[data类](https://github.com/Kotlin/KEEP/blob/master/proposals/data-class-inheritance.md)KEEPS。

### Destructuring in lambdas lambdas解构 
你可以使用[destructuring declaration](http://kotlinlang.org/docs/reference/multi-declarations.html)（解构声明）语法来解压传递给lambda的参数，以下是一个例子。

```kotlin
fun main(args: Array<String>) {
    val map = mapOf(1 to "one", 2 to "two")
    // before
    println(map.mapValues { entry ->
                           val (key, value) = entry
                           "$key -> $value!"
                          })
    // now
    println(map.mapValues { (key, value) -> "$key -> $value!" })    
}
```
有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11)和[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/destructuring-in-parameters.md)。

### 无用参数使用下划线
对于具有多个参数的lambda，可以使用_字符替换不适用的参数的名称。

```kotlin
fun main(args: Array<String>) {
    val map = mapOf(1 to "one", 2 to "two")

    map.forEach { _, value -> println("$value!") }    
}
```
这个在[destructuring declarations](http://kotlinlang.org/docs/reference/multi-declarations.html)（解构声明）中也有效。

```kotlin
data class Result(val value: Any, val status: String)

fun getResult() = Result(42, "ok").also { println("getResult() returns $it") }

fun main(args: Array<String>) {
    val (_, status) = getResult()
    println("status is '$status'")
}
```
有关详细信息，请参阅[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/underscore-for-unused-parameters.md)。

### Underscores in numeric literals 数值下划线  
就像Java 8一样，Kotlin现在允许在数值中使用下划线来分隔数字组：

```kotlin
val oneMillion = 1_000_000
val hexBytes = 0xFF_EC_DE_5E
val bytes = 0b11010010_01101001_10010100_10010010

fun main(args: Array<String>) {
    println(oneMillion)
    println(hexBytes.toString(16))
    println(bytes.toString(2))
}
```
有关详细信息，请参阅[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md)。

### Shorter syntax for properties 较短的属性语法 
对于将getter定义为表达式主体的属性，现在可以省略属性类型：

```kotlin
data class Person(val name: String, val age: Int) {
    val isAdult get() = age >= 20 // Property type inferred to be 'Boolean'
}

fun main(args: Array<String>) {
    val akari = Person("Akari", 26)
    println("$akari.isAdult = ${akari.isAdult}")
}
```
### Inline property accessors 内联属性访问器 
如果属性没有后缀字段，你现在可以使用`inline`内联修饰符标记属性访问器。 这些访问器的编译方式与[内联函数](http://kotlinlang.org/docs/reference/inline-functions.html)相同。

```kotlin
public val <T> List<T>.lastIndex: Int
inline get() = this.size - 1

fun main(args: Array<String>) {
    val list = listOf('a', 'b')
    // the getter will be inlined
    println("Last index of $list is ${list.lastIndex}")
}
```
你也可以将整个属性标记为inline - ，然后这个修饰符被两个访问器应用。

有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/inline-functions.html#inline-properties-since-11)和[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/inline-properties.md)。

### Local delegated properties 本地代理属性 
你现在可以使用代理属性语法与局部变量。一个可能的用途是定义一个延迟评估的局部变量：

```java
import java.util.Random

fun needAnswer() = Random().nextBoolean()

fun main(args: Array<String>) {
    val answer by lazy {
        println("Calculating the answer...")
        42
    }
    if (needAnswer()) {                     // returns the random value
        println("The answer is $answer.")   // answer is calculated at this point
    }
    else {
        println("Sometimes no answer is the answer...")
    }
}
```

有关详细信息，请参阅[文档](https://github.com/Kotlin/KEEP/blob/master/proposals/local-delegated-properties.md)。

### Interception of delegated property binding 拦截代理属性的绑定 
对于[delegated properties](http://kotlinlang.org/docs/reference/delegated-properties.html)（代理属性），现在可以使用`provideDelegate`运算符拦截代理给属性绑定。 例如，如果我们想在绑定之前检查属性名称，我们可以这样写：

```kotlin
class ResourceLoader<T>(id: ResourceID<T>) {
    operator fun provideDelegate(thisRef: MyUI, prop: KProperty<*>): ReadOnlyProperty<MyUI, T> {
        checkProperty(thisRef, prop.name)
        ... // property creation
    }

    private fun checkProperty(thisRef: MyUI, name: String) { ... }
}

fun <T> bindResource(id: ResourceID<T>): ResourceLoader<T> { ... }

class MyUI {
    val image by bindResource(ResourceID.image_id)
    val text by bindResource(ResourceID.text_id)
}
```
在创建MyUI实例的期间，将为每个属性调用`provideDelegate`方法，并且可以立刻执行必要的验证。

有关详细信息，请参阅[文档](http://kotlinlang.org/docs/reference/delegated-properties.html#providing-a-delegate-since-11)。

### Generic enum value access 泛型枚举值访问 
现在可以通过泛型的方式罗列枚举类的值

```kotlin
enum class RGB { RED, GREEN, BLUE }

inline fun <reified T : Enum<T>> printAllValues() {
    print(enumValues<T>().joinToString { it.name })
}

fun main(args: Array<String>) {
    printAllValues<RGB>() // prints RED, GREEN, BLUE
}
```
### Scope control for implicit receivers in DSLs DSL中隐式接收器的范围控制 

@DslMarker注释允许限制来自于DSL环境的外部范围的接收器的使用。 考虑规范的[HTML builder example](http://kotlinlang.org/docs/reference/type-safe-builders.html):

```kotlin
table {
    tr {
        td { +"Text" }
    }
}
```
在Kotlin 1.0中，传递给`td`的lambda中的代码可以使用三个隐含的接收器：传递给`table`、`tr`和`td`。 这允许你调用在环境中无意义的方法 - 例如在`td`中调用`tr`，从而将`<tr>`标签放在`<td>`中。

在Kotlin 1.1中，你可以设限制，因此只有在`td`的隐式接收器上定义的方法才能在传递给td的lambda内部可用。 您可以通过定义标注有`@DslMarker`元注释的注释并将其应用于标记类的基类来实现。

阅读[文档](http://kotlinlang.org/docs/reference/type-safe-builders.html#scope-control-dslmarker-since-11)和[KEEP](https://github.com/Kotlin/KEEP/blob/master/proposals/scope-control-for-implicit-receivers.md)了解更多详情。

### rem operator

`mod`运算符现在已被弃用，而`rem`则被替代。 看到[这个问题](https://youtrack.jetbrains.com/issue/KT-14650)的动机。

## Standard library 标准库  
### String to number conversions 字符串到数字的转换 
在String类中有一堆新的拓展就是将它转换成数字，而不会在无效的数字上抛出异常：`String.toIntOrNull(): Int?`， `String.toDoubleOrNull(): Double?` 等等。
```kotlin
val port = System.getenv("PORT")?.toIntOrNull() ?: 80
```
还有数字转换函数，如`Int.toString()`， `String.toInt()`， `String.toIntOrNull()`，每个都是用radix参数进行重载，这是允许指定转换的基础（2到36）。

### onEach()
`onEach`对集合和队列来说是一个小的，但是非常有用的拓展函数，它允许在操作链中的集合/序列的每个元素上执行一些可能具有其他作用的操作。 在iterables（可迭代对象），它的行为类似于`forEach`，但是还可以进一步返回iterable实例。 在序列上，它返回一个包装序列，它在元素被迭代时执行给定的延迟动作。
```kotlin
inputDir.walk()
        .filter { it.isFile && it.name.endsWith(".txt") }
        .onEach { println("Moving $it to $outputDir") }
        .forEach { moveFile(it, File(outputDir, it.toRelativeString(inputDir))) }
```
### also(), takeIf() and takeUnless()

这些是适用于任何接收器的三种通用扩展功能。

`also`像`apply`：它需要接收器，对它做一些动作，并返回该接收器。 不同之处在于，在`apply`内部，接收器是使用`this`获取的，而在`also`内部可以使用`it`来获取（如果需要，可以给它另一个名称）。 当你不想从外部范围映射`this`时，这很方便：

```kotlin
class Block {
    lateinit var content: String
}

fun Block.copy() = Block().also {
    it.content = this.content
}

// using 'apply' instead
fun Block.copy1() = Block().apply {
    this.content = this@copy1.content
}

fun main(args: Array<String>) {
    val block = Block().apply { content = "content" }
    val copy = block.copy()
    println("Testing the content was copied:")
    println(block.content == copy.content)
}
```
`takeIf`像`filter`一样，针对单一值，它检查接收者是否满足期望，如果它是，返回接收者，或者如果没有，则返回`null`。结合一个`elvis-operator`更早返回，它允许编码如下解构：

```kotlin
val outDirFile = File(outputDir.path).takeIf { it.exists() } ?: return false
// do something with existing outDirFile
```

```kotlin
fun main(args: Array<String>) {
    val input = "Kotlin"
    val keyword = "in"

    val index = input.indexOf(keyword).takeIf { it >= 0 } ?: error("keyword not found")
    // do something with index of keyword in input string, given that it's found
    
    println("'$keyword' was found in '$input'")
    println(input)
    println(" ".repeat(index) + "^")
}
```
`takeUnless`和`takeIf`一样，但是它的意思是反过来的。它在没有满足期望的时候返回接收器，否则返回`null`，所以上面的例子可以重写，如下：
```kotlin
val index = input.indexOf(keyword).takeUnless { it < 0 } ?: error("keyword not found")
```

当你用一个调用引替换lambda也是很方便的：
```kotlin
private fun testTakeUnless(string: String) {
    val result = string.takeUnless(String::isEmpty)

    println("string = \"$string\"; result = \"$result\"")
}

fun main(args: Array<String>) {
    testTakeUnless("")
    testTakeUnless("abc")
}
```

### groupingBy()
这个API可以通过健给集合分组，同时也可以合并每个组。例如，它可以用于计算从每个字母开始的单词数。
```kotlin
fun main(args: Array<String>) {
    val words = "one two three four five six seven eight nine ten".split(' ')
    val frequencies = words.groupingBy { it.first() }.eachCount()
    println("Counting first letters: $frequencies.")

    // The alternative way that uses 'groupBy' and 'mapValues' creates an intermediate map, 
    // while 'groupingBy' way counts on the fly.
    val groupBy = words.groupBy { it.first() }.mapValues { (_, list) -> list.size }
    println("Comparing the result with using 'groupBy': ${groupBy == frequencies}.")
}
```
### Map.toMap() and Map.toMutableMap()
这些函数可以用于轻松拷贝maps
```kotlin
class ImmutablePropertyBag(map: Map<String, Any>) {
    private val mapCopy = map.toMap()
}
/
```
### Map.minus(key)
`plus`操作符提供了一种方式将键值对加到只读的map中生成新的map，但是如果去做相反的操作就不容易了：从map中移除一个健，你不得不采取不太直接的方式，像`Map.filter()`或`Map.filterKeys()`。现在操作员减去这个差距。有四个重载可用：用于删除单个健、一个集合的健、一系列的健和一大批的健。

```kotlin
fun main(args: Array<String>) {
    val map = mapOf("key" to 42)
    val emptyMap = map - "key"
    
    println("map: $map")
    println("emptyMap: $emptyMap")
}
```

### minOf() and maxOf()
这些函数可用于查找两个或三个给定值的最低和最大值，其中值是原始数字或`Comparable`对象。 如果要比较不可比较的对象，那么每个函数也会占用一个附加的`Comparator`实例。
```kotlin
fun main(args: Array<String>) {
    val list1 = listOf("a", "b")
    val list2 = listOf("x", "y", "z")
    val minSize = minOf(list1.size, list2.size)
    val longestList = maxOf(list1, list2, compareBy { it.size })
    
    println("minSize = $minSize")
    println("longestList = $longestList")
}
```

### Array-like List instantiation functions 类似Array的List实例化函数 
类似于`Array`构造函数，现在有了创建`List`和`MutableList`实例的函数，并通过调用lambda初始化每个元素：
```kotlin
fun main(args: Array<String>) {
    val squares = List(10) { index -> index * index }
    val mutable = MutableList(10) { 0 }

    println("squares: $squares")
    println("mutable: $mutable")
}
```

### Map.getValue()
`Map`上的此扩展返回与给定键对应的现有值或引发异常，提示未找到哪个键。 如果map是`withDefault`生成的，则此函数将返回默认值，而不是抛出异常。

```kotlin
fun main(args: Array<String>) {


    val map = mapOf("key" to 42)
    // returns non-nullable Int value 42
    val value: Int = map.getValue("key")

    val mapWithDefault = map.withDefault { k -> k.length }
    // returns 4
    val value2 = mapWithDefault.getValue("key2")

    // map.getValue("anotherKey") // <- this will throw NoSuchElementException
    
    println("value is $value")
    println("value2 is $value2")
}
```

### Abstract collections 抽象集合 
这些抽象类可以在实现Kotlin集合类时用作基类。为了实现只读的集合，有`AbstractCollection`，`AbstractList`，`AbstractSet`和`AbstractMap`，对于可变集合，还有`AbstractMutableCollection`，`AbstractMutableList`，`AbstractMutableSet`和`AbstractMutableMap`。在JVM上，这些抽象可变集合从JDK的抽象集合继承其大部分功能。

### Array manipulation functions 数组操作功能 
标准库现在提供了一组用于逐个元素操作的函数：比较（`contentEquals`和`contentDeepEquals`），哈希码计算（`contentHashCode`和`contentDeepHashCode`）以及转换为字符串（`contentToString`和`contentDeepToString`）。它们都支持JVM（它们作为`java.util.Arrays`中的相应函数的别名）和JS（在Kotlin标准库中提供实现）。
```kotlin
fun main(args: Array<String>) {
    val array = arrayOf("a", "b", "c")
    println(array.toString())  // JVM implementation: type-and-hash gibberish
    printlnå(array.contentToString())  // nicely formatted as list
}
```

## JVM Backend Jvm 后端 
### Java 8字节码支持

Kotlin现在可以选择生成Java 8字节码（`-jvm-target 1.8`命令行选项或Ant / Maven / Gradle中的相应选项）。 现在这并不会改变字节码的语义（特别是接口和lambdas中的默认方法与Kotlin 1.0完全相同），但是我们打算进一步利用这一点。

### Java 8 standard library support Java 8标准库支持 

现在有标准库的单独版本支持在Java 7和8中添加的新JDK API。如果需要访问新的API，请使用`kotlin-stdlib-jre7`和`kotlin-stdlib-jre8` maven工件，而不是标准的`kotlin-stdlib`。 这些东西是在`kotlin-stdlib`之上的微型扩展，它们将它作为可传递的依赖关系带入你的项目。

### Parameter names in the bytecode 字节码中的参数名称 
Kotlin现在支持在字节码中存储参数名称。 这可以使用`-java-parameters`命令行选项启用。

### Constant inlining 内联常量 
现在编译器将`const val`属性的值嵌入到使用它们的位置。

### Mutable closure variables 可变闭包变量 
这个框类用于捕获lambdas中可变闭包变量，不再有volatile字段。 这种改变提高了性能，但是在一些罕见的使用情况下可能会导致新的状况。 如果受此影响，你需要提供自己的同步来获取变量。


### javax.script support
Kotlin现在与[javax.script API](https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html)（JSR-223）集成。 API允许在运行时评估代码段：
```kotlin
val engine = ScriptEngineManager().getEngineByExtension("kts")!!
engine.eval("val x = 3")
println(engine.eval("x + 2"))  // Prints out 5
```
请参阅[这里](https://github.com/JetBrains/kotlin/tree/master/libraries/examples/kotlin-jsr223-local-example)使用API的更大的示例项目。

### kotlin.reflect.full
为了[prepare for Java 9 support](https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/)，`kotlin-reflect.jar`库中的扩展函数和属性已被移动到包`kotlin.reflect.full`。 旧包中的名称（`kotlin.reflect`）已被弃用，将在Kotlin 1.2中删除。 请注意，核心反射接口（如`KClass`）是Kotlin标准库的一部分，不是`kotlin-reflect`，不受移动影响。

## JavaScript Backend
### Unified standard library 统一标准库 
Kotlin标准库的大部分现在可以从编译为JavaScript的代码中使用。特别地，`kotlin`包下定义了关键类，如集合（`ArrayList`，`HashMap`等），异常（`IllegalArgumentException`等）和其他几个（`StringBuilder`，`Comparator`）。在JVM上，这些名称是相应JDK类的类别别名，而在JS上，这些类在Kotlin标准库中实现。

### Better code generation 更好的代码生成 
JavaScript后端现在可以生成更多的静态可检查代码，这对JS代码处理工具（比如minifier，optimizers，linters等）来说更为友善。

### The external modifier 外部修饰符 
如果您需要以类型安全的方式访问Kotlin中以JavaScript实现的类，则可以使用`external`修饰符编写Kotlin声明。 （在Kotlin 1.0中，使用`@native`注释。）与JVM目标不同，JS允许使用带有类和属性的外部修饰符。例如，下面是如何声明DOM `Node`类：
```kotlin
external class Node {
    val firstChild: Node

    fun appendChild(child: Node): Node

    fun removeChild(child: Node): Node

    // etc
}
```
### Improved import handling 改进导入功能 
你现在可以更精确地描述应该从JavaScript模块导入的声明。 如果在外部声明中添加了`@JsModule("<module-name>")`注释，那么在编译期间它将被正确地导入模块系统（CommonJS或AMD）。 例如，使用CommonJS，声明将通过`require(...)`函数导入。 另外，如果要将声明导入为模块或全局JavaScript对象，则可以使用`@JsNonModule`注释。

例如，以下是将JQuery导入Kotlin模块的方法：
```kotlin
external interface JQuery {
    fun toggle(duration: Int = definedExternally): JQuery
    fun click(handler: (Event) -> Unit): JQuery
}

@JsModule("jquery")
@JsNonModule
@JsName("$")
external fun jquery(selector: String): JQuery
```
在这种情况下，JQuery将被导入为一个名为`jquery`的模块。或者，它可以用作$对象，具体取决于Kotlin编译器配置使用的模块系统。

你可以在应用程序中使用这些声明，如下所示：
```kotlin
fun main(args: Array<String>) {
    jquery(".toggle-button").click {
        jquery(".toggle-panel").toggle(300)
    }
}
```
